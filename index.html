<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VJudge Contest Team Checker - Standalone</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 28px;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .header p {
      opacity: 0.9;
      font-size: 14px;
    }

    .setup-banner {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 16px 20px;
      margin: 20px 30px;
      border-radius: 8px;
      font-size: 13px;
      color: #856404;
    }

    .setup-banner h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #856404;
    }

    .setup-banner ul {
      margin: 8px 0 0 20px;
    }

    .setup-banner li {
      margin: 4px 0;
    }

    .setup-banner code {
      background: #f8f9fa;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }

    .content {
      padding: 30px;
    }

    .form-group {
      margin-bottom: 24px;
    }

    label {
      display: block;
      font-weight: 600;
      color: #333;
      margin-bottom: 12px;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    label .icon {
      color: #667eea;
      font-size: 18px;
    }

    input[type="text"] {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .input-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .input-item {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .input-item input {
      flex: 1;
    }

    .btn-add, .btn-remove {
      padding: 10px 16px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
    }

    .btn-add {
      background: #f0f0f0;
      color: #667eea;
      border: 2px solid #667eea;
      width: 100%;
      margin-top: 8px;
    }

    .btn-add:hover {
      background: #667eea;
      color: white;
    }

    .btn-remove {
      background: #ffebee;
      color: #c62828;
      padding: 10px 14px;
      font-size: 18px;
      line-height: 1;
    }

    .btn-remove:hover {
      background: #c62828;
      color: white;
    }

    .results-wrapper {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .aggregate-card {
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid #ebe8ff;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.15);
      padding: 24px;
      margin-bottom: 30px;
    }

    .aggregate-header {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 16px;
    }

    .aggregate-header h2 {
      font-size: 20px;
      color: #4b4b7c;
      margin: 0;
    }

    .aggregate-header p {
      font-size: 14px;
      color: #777;
      margin: 0;
    }

    .merge-mode {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .merge-mode label {
      font-weight: 500;
      color: #4b4b7c;
      font-size: 14px;
      gap: 6px;
    }

    .contest-chips {
      display: none;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 16px;
    }

    .contest-chips.active {
      display: flex;
    }

    .contest-chip {
      border: 1px solid #dcd6ff;
      border-radius: 999px;
      padding: 6px 14px;
      background: #f7f5ff;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #4b4b7c;
      cursor: pointer;
    }

    .contest-chip input {
      width: 14px;
      height: 14px;
      margin: 0;
    }

    .chips-empty {
      font-size: 13px;
      color: #777;
      margin: 0;
    }

    .aggregate-results {
      border-top: 1px solid #f0edff;
      padding-top: 16px;
    }

    .aggregate-empty {
      padding: 12px 0;
      color: #777;
      font-size: 14px;
    }

    .aggregate-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    .aggregate-table th,
    .aggregate-table td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid #f0edff;
    }

    .aggregate-table th {
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #6c63ff;
    }

    .aggregate-table tbody tr:hover {
      background: #f9f8ff;
    }

    .rating-card {
      background: #ffffff;
      border-radius: 16px;
      border: 1px solid #e3f2fd;
      box-shadow: 0 8px 24px rgba(118, 75, 162, 0.15);
      padding: 24px;
      margin-bottom: 30px;
    }

    .rating-header h2 {
      font-size: 20px;
      color: #334155;
      margin: 0;
    }

    .rating-header p {
      font-size: 14px;
      color: #64748b;
      margin: 6px 0 0;
    }

    .elo-mode {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin: 16px 0;
    }

    .elo-mode label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: #475569;
      background: #f1f5f9;
      border-radius: 999px;
      padding: 6px 12px;
      cursor: pointer;
    }

    .elo-mode input {
      margin: 0;
    }

    .rating-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 16px;
      font-size: 14px;
    }

    .rating-table th,
    .rating-table td {
      text-align: left;
      padding: 10px 12px;
      border-bottom: 1px solid #f1f5f9;
    }

    .rating-table th {
      background: #f8fafc;
      color: #475569;
      font-size: 12px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }

    .rating-table tbody tr:hover {
      background: #f5f3ff;
    }

    .rating-table .rating-col {
      font-variant-numeric: tabular-nums;
      color: #0f172a;
      font-weight: 600;
    }

    .rating-table .record-col {
      font-variant-numeric: tabular-nums;
      color: #475569;
    }

    .elo-empty {
      padding: 12px 0;
      color: #64748b;
      font-size: 14px;
    }

    button.btn-check {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 14px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      width: 100%;
    }

    button.btn-check:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }

    button.btn-check:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
    }

    .divider {
      height: 2px;
      background: linear-gradient(90deg, transparent, #e0e0e0, transparent);
      margin: 30px 0;
    }

    #results {
      margin-top: 20px;
    }

    .contest {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 24px;
      margin-bottom: 24px;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .contest h2 {
      color: #667eea;
      font-size: 20px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .contest h2::before {
      content: 'üèÜ';
      font-size: 24px;
    }

    .contest h2 a {
      color: #667eea;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .contest h2 a:hover {
      color: #764ba2;
      text-decoration: underline;
    }

    .contest-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .contest-table thead {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .contest-table th {
      padding: 12px 16px;
      text-align: left;
      font-weight: 600;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .contest-table td {
      padding: 12px 16px;
      border-bottom: 1px solid #f0f0f0;
      font-size: 14px;
    }

    .contest-table tbody tr:hover {
      background: #f9f8ff;
    }

    .contest-table tbody tr:last-child td {
      border-bottom: none;
    }

    .contest-table .rank-col {
      font-weight: 600;
      color: #667eea;
      width: 60px;
    }

    .contest-table .team-col {
      font-weight: 600;
      color: #333;
    }

    .contest-table .solved-col {
      color: #29ad30;
      font-weight: 600;
      width: 80px;
    }

    .contest-table .penalty-col {
      color: #424242;
      width: 120px;
    }

    .contest-table .status-col {
      width: 80px;
    }

    .status-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
    }

    .status-found {
      background: #e8f5e9;
      color: #29ad30;
    }

    .status-registered {
      background: #fff3e0;
      color: #e65100;
    }

    .status-not-found {
      background: #ffebee;
      color: #c62828;
    }

    .team {
      background: white;
      padding: 12px 16px;
      margin: 8px 0;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .team.found {
      border-left: 4px solid #4caf50;
    }

    .team.not-found {
      border-left: 4px solid #ff9800;
      opacity: 0.7;
    }

    .team-name {
      font-weight: 600;
      color: #333;
    }

    .team-stats {
      color: #666;
      margin-left: auto;
    }

    .team-meta {
      font-size: 12px;
      color: #777;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .spinner {
      border: 3px solid #f3f3f3;
      border-top: 3px solid #667eea;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 16px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .error {
      background: #ffebee;
      border: 1px solid #ef5350;
      color: #c62828;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .container {
        border-radius: 0;
      }
      
      .content {
        padding: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>VJudge Contest Team Checker</h1>
      <p>Track team performance across multiple contests</p>
    </div>

    <div class="content">
      <div class="form-group">
        <label>
          <span class="icon">üèÜ</span>
          Contest IDs
        </label>
        <input type="text" id="contestInput" placeholder="Enter contest IDs separated by commas (e.g., 123456, 789012)">
      </div>

      <div class="form-group">
        <label>
          <span class="icon">üë•</span>
          Team Names
        </label>
        <input type="text" id="teamInput" placeholder="Enter team names separated by commas (e.g., team1, team2)">
      </div>

      <div class="form-group" style="display: flex; align-items: center; gap: 12px;">
        <label style="margin: 0; cursor: pointer;">
          <input type="checkbox" id="includeUpsolve" style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;">
          <span>Include Upsolve (submissions after contest ends)</span>
        </label>
      </div>

      <div class="aggregate-card">
        <div class="aggregate-header">
          <h2>Combined Ranking</h2>
          <p>Merge results across contests and view a single leaderboard.</p>
        </div>
        <div class="merge-mode">
          <label>
            <input type="radio" name="mergeMode" value="all" checked>
            Merge all contests
          </label>
          <label>
            <input type="radio" name="mergeMode" value="custom">
            Select contests to merge
          </label>
        </div>
        <div id="contestChips" class="contest-chips"></div>
        <div id="aggregateResults" class="aggregate-results">
          <div class="aggregate-empty">Run "Check Teams" to build the combined ranking.</div>
        </div>
      </div>

      <div class="rating-card">
        <div class="rating-header">
          <h2>Total Standings (Elo Rating)</h2>
          <p>Exact Elo updates across contests with high-precision ratings.</p>
        </div>
        <div class="elo-mode">
          <label>
            <input type="radio" name="eloMode" value="zero-participation">
            Participation required (missing teams count as 0 solve)
          </label>
          <label>
            <input type="radio" name="eloMode" value="gain-only">
            Gain-only rating (no decreases)
          </label>
          <label>
            <input type="radio" name="eloMode" value="normal" checked>
            Classic Elo (default)
          </label>
        </div>
        <div id="eloResults" class="elo-results">
          <div class="elo-empty">Enter contests and teams to compute Elo standings.</div>
        </div>
      </div>

      <div class="divider"></div>

      <div id="results"></div>
    </div>
  </div>

  <script>
    // ============================================================
    // COMPLETE APPLICATION LOGIC - ALL IN ONE FILE
    // ============================================================

    // Direct API access - works with Live Server
    const USE_DIRECT_API = true;
    
    console.log('VJudge API Mode: Direct (Live Server compatible)');
    console.log('Current origin:', window.location.origin);

    const contestCache = new Map();
    const contestInfoCache = new Map(); // Store contest names
    const selectionState = {
      mode: 'all',
      contestIds: [],
      selected: new Set(),
      eloMode: 'normal'
    };
    let autoRefreshTimer = null;
    let contestFetchTimer = null;
    const AUTO_REFRESH_DELAY = 800;
    const CONTEST_FETCH_DELAY = 500;

    function registerInputListener(inputId) {
      const input = document.getElementById(inputId);
      if (!input) return;
      
      if (inputId === 'contestInput') {
        input.addEventListener('input', () => {
          scheduleContestFetch();
        });
      } else {
        input.addEventListener('input', () => {
          scheduleAutoRefresh();
        });
      }
    }

    function scheduleContestFetch() {
      clearTimeout(contestFetchTimer);
      contestFetchTimer = setTimeout(() => {
        fetchAndDisplayContests();
      }, CONTEST_FETCH_DELAY);
    }

    async function fetchAndDisplayContests() {
      const { contestIds, invalidIds } = collectInputs();
      
      const container = document.getElementById('results');
      
      // Show validation errors for invalid IDs
      if (invalidIds.length > 0) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error';
        errorDiv.style.marginBottom = '16px';
        errorDiv.innerHTML = `<strong>Invalid Contest IDs:</strong> Contest IDs must be numbers only. Invalid entries: ${invalidIds.join(', ')}`;
        container.innerHTML = '';
        container.appendChild(errorDiv);
        prepareAggregateView([]);
        refreshAggregateRanking();
        refreshEloStandings();
        return;
      }
      
      if (!contestIds.length) {
        container.innerHTML = '';
        prepareAggregateView([]);
        refreshAggregateRanking();
        refreshEloStandings();
        return;
      }

      const fragment = document.createDocumentFragment();

      for (const contestId of contestIds) {
        // Skip if already fetched successfully
        if (contestCache.has(contestId) && contestInfoCache.has(contestId)) {
          continue;
        }

        const contestDiv = document.createElement('div');
        contestDiv.className = 'contest';
        contestDiv.id = `contest-${contestId}`;

        // Show loading state
        contestDiv.innerHTML = `<h2>Contest ${contestId}</h2><div class="loading" style="padding: 20px;"><div class="spinner"></div><p>Fetching contest data...</p></div>`;
        
        // Try to fetch
        const contestData = await ensureContestData(contestId, { forceRefetch: false });
        
        if (contestData.error) {
          const contestName = contestInfoCache.get(contestId) || `Contest ${contestId}`;
          const contestUrl = `https://vjudge.net/contest/${contestId}`;
          contestDiv.innerHTML = `<h2><a href="${contestUrl}" target="_blank" rel="noopener noreferrer">${contestName}</a></h2><div class="error">${contestData.error}</div>`;
        } else {
          const contestName = contestInfoCache.get(contestId) || `Contest ${contestId}`;
          const contestUrl = `https://vjudge.net/contest/${contestId}`;
          contestDiv.innerHTML = `<h2><a href="${contestUrl}" target="_blank" rel="noopener noreferrer">${contestName}</a></h2><div class="team" style="border-left: 4px solid #2196F3; background: #E3F2FD;"><span class="team-name">‚úì Contest loaded successfully</span><span>Add team names to view rankings</span></div>`;
        }
        
        fragment.appendChild(contestDiv);
      }

      // Update or append contest divs
      const existingContests = new Set(
        Array.from(container.querySelectorAll('.contest'))
          .map(div => div.id.replace('contest-', ''))
      );

      // Remove contests that are no longer in the input
      Array.from(container.querySelectorAll('.contest')).forEach(div => {
        const id = div.id.replace('contest-', '');
        if (!contestIds.includes(id)) {
          div.remove();
        }
      });

      // Append new contests
      if (fragment.childNodes.length > 0) {
        container.appendChild(fragment);
      }

      prepareAggregateView(contestIds);
      refreshAggregateRanking();
      refreshEloStandings();
      scheduleAutoRefresh();
    }

    function scheduleAutoRefresh() {
      clearTimeout(autoRefreshTimer);
      autoRefreshTimer = setTimeout(() => {
        renderResults({ forceRefetch: false, useCacheOnly: false, showSpinner: false, silentErrors: true })
          .catch(err => console.error('Auto refresh error', err));
      }, AUTO_REFRESH_DELAY);
    }

    function initAggregateControls() {
      const modeRadios = document.querySelectorAll('input[name="mergeMode"]');
      modeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          selectionState.mode = radio.value;
          if (selectionState.mode === 'all') {
            selectionState.selected = new Set(selectionState.contestIds);
          } else if (!selectionState.selected.size && selectionState.contestIds.length) {
            selectionState.selected = new Set([selectionState.contestIds[0]]);
          }
          updateContestChips(selectionState.contestIds);
          refreshAggregateRanking();
          refreshEloStandings();
        });
      });

      const chipsContainer = document.getElementById('contestChips');
      if (chipsContainer) {
        chipsContainer.addEventListener('change', (event) => {
          if (event.target.matches('input[type="checkbox"]')) {
            const contestId = event.target.value;
            if (event.target.checked) {
              selectionState.selected.add(contestId);
            } else {
              selectionState.selected.delete(contestId);
            }
            refreshAggregateRanking();
            refreshEloStandings();
          }
        });
      }
    }

    function initEloModeControls() {
      const eloRadios = document.querySelectorAll('input[name="eloMode"]');
      eloRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (!radio.checked) return;
          selectionState.eloMode = radio.value;
          refreshEloStandings();
        });
      });
    }

    function updateContestChips(contestIds) {
      const chips = document.getElementById('contestChips');
      if (!chips) return;
      chips.innerHTML = '';

      if (!contestIds.length) {
        chips.innerHTML = '<p class="chips-empty">Enter contest IDs to load options.</p>';
        chips.classList.remove('active');
        return;
      }

      contestIds.forEach(id => {
        const label = document.createElement('label');
        label.className = 'contest-chip';
        const checked = selectionState.selected.has(id);
        const disabledAttr = selectionState.mode !== 'custom' ? 'disabled' : '';
        const contestName = contestInfoCache.get(id) || `Contest ${id}`;
        label.innerHTML = `
          <input type="checkbox" value="${id}" ${checked ? 'checked' : ''} ${disabledAttr}>
          <span>${contestName}</span>
        `;
        chips.appendChild(label);
      });

      chips.classList.toggle('active', selectionState.mode === 'custom');
    }

    async function fetchContestRank(contestId) {
      try {
        // Direct API call to VJudge
        const url = `https://vjudge.net/contest/rank/single/${contestId}`;
        
        const resp = await fetch(url, {
          method: 'GET',
          mode: 'cors',
          credentials: 'omit',
          headers: {
            'Accept': 'application/json'
          }
        });
        
        if (!resp.ok) {
          console.warn('Could not fetch rank for contest', contestId, resp.status);
          return { error: `Contest ${contestId} not found or is private` };
        }
        
        const data = await resp.json();
        
        // Store contest name if available
        if (data.title) {
          contestInfoCache.set(contestId, data.title);
        }
        
        return data;
      } catch (error) {
        console.error('Fetch error for contest', contestId, error);
        
        // More helpful error message
        let errorMessage = error.message;
        if (error.message === 'Failed to fetch' || error.name === 'TypeError') {
          errorMessage = `Contest ${contestId} not found or network error`;
        }
        
        return { error: errorMessage };
      }
    }

    const PENALTY_PER_WRONG = 20 * 60; // 20 ICPC minutes in seconds
    const ELO_BASE_RATING = 1500;
    const ELO_K_FACTOR = 32;

    const normalizeName = (value = '') => value.toLowerCase().replace(/[^a-z0-9]/g, '');

    function formatPenalty(seconds) {
      if (typeof seconds !== 'number' || !Number.isFinite(seconds) || seconds <= 0) {
        return '0s';
      }
      const totalSeconds = Math.round(seconds);
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const secs = totalSeconds % 60;
      const parts = [];
      if (hours) parts.push(`${hours}h`);
      if (hours || minutes) parts.push(`${minutes}m`);
      parts.push(`${secs}s`);
      return parts.join(' ');
    }

    function formatRating(value) {
      if (!Number.isFinite(value)) {
        return ELO_BASE_RATING.toFixed(4);
      }
      return value.toFixed(4);
    }

    function splitTeamInput(rawValue = '') {
      const tokens = [];
      let buffer = '';
      let depth = 0;
      for (const ch of rawValue) {
        if (ch === '(') {
          if (depth === 0 && buffer.trim()) {
            tokens.push(buffer.trim());
            buffer = '';
          }
          depth += 1;
          buffer += ch;
        } else if (ch === ')') {
          depth = Math.max(0, depth - 1);
          buffer += ch;
        } else if (ch === ',' && depth === 0) {
          if (buffer.trim()) {
            tokens.push(buffer.trim());
          }
          buffer = '';
        } else {
          buffer += ch;
        }
      }
      if (buffer.trim()) {
        tokens.push(buffer.trim());
      }
      return tokens;
    }

    function parseTeamGroups(rawValue = '') {
      const tokens = splitTeamInput(rawValue);
      const teamGroups = [];
      tokens.forEach((token, index) => {
        let content = token;
        if (token.startsWith('(') && token.endsWith(')')) {
          content = token.slice(1, -1);
        }
        const aliases = content.split(',').map(v => v.trim()).filter(Boolean);
        if (!aliases.length) {
          return;
        }
        const normalizedAliases = aliases
          .map(alias => normalizeName(alias))
          .filter(Boolean);
        const groupId = `team-group-${teamGroups.length}`;
        teamGroups.push({
          id: groupId,
          displayName: aliases[0],
          aliases,
          normalizedAliases
        });
      });
      return { teamGroups };
    }

    function normalizeSecondsValue(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num <= 0) return null;
      return num > 1e7 ? Math.round(num / 1000) : Math.round(num);
    }

    function normalizeTimestampValue(value) {
      const num = Number(value);
      if (!Number.isFinite(num) || num <= 0) return null;
      return num > 1e12 ? Math.round(num / 1000) : Math.round(num);
    }

    function resolveContestLength(rankData) {
      if (!rankData) return Infinity;
      const directSources = [
        rankData.length,
        rankData.duration,
        rankData.contestLength,
        rankData?.contest?.length,
        rankData?.contest?.duration
      ];
      for (const source of directSources) {
        const seconds = normalizeSecondsValue(source);
        if (seconds) return seconds;
      }

      const startCandidates = [
        rankData.startTime,
        rankData.begin,
        rankData.beginTime,
        rankData.start,
        rankData?.contest?.startTime,
        rankData?.contest?.begin
      ];
      const endCandidates = [
        rankData.endTime,
        rankData.finishTime,
        rankData.end,
        rankData?.contest?.endTime,
        rankData?.contest?.end
      ];

      const startSeconds = startCandidates
        .map(candidate => normalizeTimestampValue(candidate))
        .find(value => Number.isFinite(value));
      const endSeconds = endCandidates
        .map(candidate => normalizeTimestampValue(candidate))
        .find(value => Number.isFinite(value));

      if (startSeconds && endSeconds && endSeconds > startSeconds) {
        return normalizeSecondsValue(endSeconds - startSeconds) || Infinity;
      }

      return Infinity;
    }

    function buildRanklist(rankData) {
      // Always rebuild so we can filter upsolves consistently
      if (!rankData?.participants || !Array.isArray(rankData?.submissions)) {
        if (Array.isArray(rankData?.ranklist) && rankData.ranklist.length) {
          return rankData.ranklist;
        }
        return null;
      }

      const includeUpsolve = document.getElementById('includeUpsolve')?.checked || false;
      const contestLength = resolveContestLength(rankData);

      const teams = new Map();
      Object.entries(rankData.participants).forEach(([teamId, info]) => {
        const username = info?.[0] || '';
        const displayName = info?.[1] || username || `Team ${teamId}`;
        teams.set(Number(teamId), {
          teamId: Number(teamId),
          displayName,
          username,
          aliases: Array.from(new Set([
            displayName,
            username,
            displayName.replace(/_/g, ' '),
            username.replace(/_/g, ' ')
          ].filter(Boolean))),
          solved: 0,
          penalty: 0,
          submissions: 0,
          attempted: false,
          problems: new Map()
        });
      });

      const orderedSubs = rankData.submissions
        .map(entry => ({
          teamId: Number(entry[0]),
          problemId: entry[1],
          accepted: entry[2] === 1,
          time: entry[3] || 0
        }))
        .filter(sub => {
          // If not including upsolve, filter out submissions after contest end
          if (!includeUpsolve && contestLength !== Infinity) {
            return sub.time <= contestLength;
          }
          return true;
        })
        .sort((a, b) => a.time - b.time);

      orderedSubs.forEach(sub => {
        const team = teams.get(sub.teamId);
        if (!team) return;
        team.attempted = true;
        team.submissions += 1;
        let problemRecord = team.problems.get(sub.problemId);
        if (!problemRecord) {
          problemRecord = { wrong: 0, solved: false };
          team.problems.set(sub.problemId, problemRecord);
        }
        if (problemRecord.solved) return;
        if (sub.accepted) {
          problemRecord.solved = true;
          problemRecord.time = sub.time;
          team.solved += 1;
          team.penalty += sub.time + problemRecord.wrong * PENALTY_PER_WRONG;
        } else {
          problemRecord.wrong += 1;
        }
      });

      const ranked = Array.from(teams.values())
        .filter(team => team.attempted || team.solved)
        .sort((a, b) => {
          if (b.solved !== a.solved) return b.solved - a.solved;
          return (a.penalty || 0) - (b.penalty || 0);
        });

      let prevKey = null;
      let currentRank = 0;
      ranked.forEach((team, index) => {
        const key = `${team.solved}-${team.penalty}`;
        if (key !== prevKey) {
          currentRank = index + 1;
          prevKey = key;
        }
        team.rank = currentRank;
      });

      return ranked.map(team => {
        const displayPenalty = formatPenalty(team.penalty);
        return {
          team_id: team.teamId,
          team_name: team.displayName,
          rank: team.rank,
          solved: team.solved,
          penalty: team.penalty,
          penaltyDisplay: displayPenalty,
          time: displayPenalty,
          submissions: team.submissions,
          aliases: team.aliases
        };
      });
    }

    function collectInputs() {
      const contestInput = document.getElementById('contestInput');
      const teamInput = document.getElementById('teamInput');
      
      const invalidIds = [];
      const contestIds = (contestInput?.value || '')
        .split(',')
        .map(v => {
          const value = v.trim();
          if (!value) return null;
          // Check if it's a valid number
          if (!/^\d+$/.test(value)) {
            invalidIds.push(value);
            return null;
          }
          return value;
        })
        .filter(Boolean);
      
      const { teamGroups } = parseTeamGroups(teamInput?.value || '');
      
      return { contestIds, teamGroups, invalidIds };
    }

    async function ensureContestData(contestId, { forceRefetch = false } = {}) {
      if (!forceRefetch && contestCache.has(contestId)) {
        return contestCache.get(contestId);
      }

      const rankData = await fetchContestRank(contestId);
      if (!rankData || rankData.error) {
        return { error: rankData?.error || 'Unknown error' };
      }

      const ranklist = buildRanklist(rankData);
      if (!ranklist) {
        return { error: 'No ranklist data was returned. VJudge may be throttling anonymous API calls.' };
      }

      const payload = {
        ranklist,
        participants: rankData.participants || {},
        fetchedAt: Date.now()
      };
      contestCache.set(contestId, payload);
      return payload;
    }

    function renderTeamsForContest(contestDiv, contestData, teamGroups) {
      const rows = [];
      
      for (const group of teamGroups) {
        const match = findBestGroupMatch(group, contestData.ranklist, contestData.participants);
        if (match?.entry) {
          const entry = match.entry;
          const contestRank = entry.rank ?? '‚Äî';
          const numericRank = Number(contestRank);
          const rankValue = Number.isFinite(numericRank) ? numericRank : 999999;
          rows.push({
            team: group.displayName,
            alias: match.alias,
            contestRank,
            solved: entry.solved ?? '‚Äî',
            penalty: entry.penaltyDisplay || entry.penalty || entry.time || '‚Äî',
            status: 'found',
            statusText: 'Found',
            rankValue
          });
        } else if (match?.participant) {
          rows.push({
            team: group.displayName,
            alias: match.alias,
            contestRank: '‚Äî',
            solved: '‚Äî',
            penalty: '‚Äî',
            status: 'registered',
            statusText: 'Registered',
            rankValue: 999999
          });
        } else {
          rows.push({
            team: group.displayName,
            alias: null,
            contestRank: '‚Äî',
            solved: '‚Äî',
            penalty: '‚Äî',
            status: 'not-found',
            statusText: 'Not Found',
            rankValue: 999999
          });
        }
      }
      
      // Sort teams by their contest ranking (best placements first)
      rows.sort((a, b) => a.rankValue - b.rankValue);

      let prevKey = null;
      let currentRank = 0;
      rows.forEach((row, index) => {
        const key = row.rankValue;
        if (key !== prevKey) {
          currentRank = index + 1;
          prevKey = key;
        }
        row.displayRank = currentRank;
      });

      if (rows.length === 0) return;

      const tableHTML = `
        <table class="contest-table">
          <thead>
            <tr>
              <th class="rank-col">Rank</th>
              <th class="team-col">Team Name</th>
              <th class="solved-col">Solved</th>
              <th class="penalty-col">Penalty</th>
              <th class="status-col">Status</th>
            </tr>
          </thead>
          <tbody>
            ${rows.map(row => `
              <tr>
                <td class="rank-col">${row.displayRank}</td>
                <td class="team-col">
                  <div class="team-name">${row.team}</div>
                  ${row.alias ? `<div class="team-meta">Matched as: ${row.alias}</div>` : ''}
                  ${row.contestRank !== '‚Äî' ? `<div class="team-meta">Contest rank: ${row.contestRank}</div>` : ''}
                </td>
                <td class="solved-col">${row.solved}</td>
                <td class="penalty-col">${row.penalty}</td>
                <td class="status-col"><span class="status-badge status-${row.status}">${row.statusText}</span></td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      `;
      
      contestDiv.innerHTML += tableHTML;
    }

    function prepareAggregateView(contestIds) {
      const uniqueIds = Array.from(new Set(contestIds));

      const previousSelection = new Set(selectionState.selected);
      selectionState.contestIds = uniqueIds;

      if (selectionState.mode === 'all') {
        selectionState.selected = new Set(uniqueIds);
      } else {
        const filtered = uniqueIds.filter(id => previousSelection.has(id));
        selectionState.selected = new Set(filtered);
        if (!selectionState.selected.size && uniqueIds.length) {
          selectionState.selected.add(uniqueIds[0]);
        }
      }

      updateContestChips(uniqueIds);
    }

    function refreshAggregateRanking() {
      const aggregateContainer = document.getElementById('aggregateResults');
      if (!aggregateContainer) return;

      const { teamGroups } = collectInputs();
      if (!teamGroups.length) {
        aggregateContainer.innerHTML = '<div class="aggregate-empty">Add at least one team to view the combined ranking.</div>';
        return;
      }

      const contestIds = selectionState.mode === 'all'
        ? selectionState.contestIds
        : Array.from(selectionState.selected);

      if (!contestIds.length) {
        aggregateContainer.innerHTML = '<div class="aggregate-empty">Select at least one contest to merge.</div>';
        return;
      }

      const missingData = contestIds.some(id => !contestCache.has(id));
      if (missingData) {
        aggregateContainer.innerHTML = '<div class="aggregate-empty">Fetching contest data...</div>';
        return;
      }

      const rows = buildAggregateRanking(contestIds, teamGroups);
      if (!rows.length) {
        aggregateContainer.innerHTML = '<div class="aggregate-empty">Teams were not found in the selected contests.</div>';
        return;
      }

      const tbody = rows.map(row => `
        <tr>
          <td>${row.rank}</td>
          <td>
            <div class="team-name">${row.displayName}</div>
            <div class="team-meta">${row.appearances} contest${row.appearances === 1 ? '' : 's'} with results</div>
          </td>
          <td>${row.appearances} / ${contestIds.length}</td>
          <td>${row.solved}</td>
          <td>${row.penaltyDisplay}</td>
        </tr>
      `).join('');

      aggregateContainer.innerHTML = `
        <table class="aggregate-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>Contests</th>
              <th>Solved</th>
              <th>Penalty</th>
            </tr>
          </thead>
          <tbody>${tbody}</tbody>
        </table>
      `;
    }

    function normalizePenaltyValue(entry) {
      if (!entry) return 0;
      if (typeof entry.penalty === 'number') return entry.penalty;
      if (typeof entry.time === 'number') return entry.time;
      const numericPenalty = Number(entry.penalty);
      if (!Number.isNaN(numericPenalty)) return numericPenalty;
      return 0;
    }

    function buildAggregateRanking(contestIds, teamGroups) {
      const statsByTeam = new Map();
      teamGroups.forEach(group => {
        statsByTeam.set(group.id, {
          id: group.id,
          displayName: group.displayName,
          solved: 0,
          penalty: 0,
          appearances: 0
        });
      });

      for (const contestId of contestIds) {
        const contestData = contestCache.get(contestId);
        if (!contestData) continue;
        for (const group of teamGroups) {
          const stats = statsByTeam.get(group.id);
          if (!stats) continue;
          const match = findBestGroupMatch(group, contestData.ranklist, contestData.participants);
          if (match?.entry) {
            stats.appearances += 1;
            stats.solved += Number(match.entry.solved) || 0;
            stats.penalty += normalizePenaltyValue(match.entry);
          }
        }
      }

      const rows = Array.from(statsByTeam.values())
        .map(row => ({
          ...row,
          penaltyDisplay: formatPenalty(row.penalty)
        }))
        .sort((a, b) => {
          if (b.solved !== a.solved) return b.solved - a.solved;
          if (a.penalty !== b.penalty) return a.penalty - b.penalty;
          return a.displayName.localeCompare(b.displayName);
        });

      let currentRank = 0;
      let prevKey = null;
      rows.forEach((row, index) => {
        const key = `${row.solved}-${row.penalty}`;
        if (key !== prevKey) {
          currentRank = index + 1;
          prevKey = key;
        }
        row.rank = currentRank;
      });

      return rows;
    }

    function refreshEloStandings() {
      const eloContainer = document.getElementById('eloResults');
      if (!eloContainer) return;

      const { teamGroups } = collectInputs();
      if (!teamGroups.length) {
        eloContainer.innerHTML = '<div class="elo-empty">Add at least one team to compute Elo standings.</div>';
        return;
      }

      const contestIds = selectionState.mode === 'all'
        ? selectionState.contestIds
        : Array.from(selectionState.selected);

      if (!contestIds.length) {
        eloContainer.innerHTML = '<div class="elo-empty">Select contests to include in the Elo standings.</div>';
        return;
      }

      const missingData = contestIds.some(id => !contestCache.has(id));
      if (missingData) {
        eloContainer.innerHTML = '<div class="elo-empty">Fetching contest data...</div>';
        return;
      }

      const rows = buildEloStandings(contestIds, teamGroups, selectionState.eloMode || 'normal');
      if (!rows.length) {
        eloContainer.innerHTML = '<div class="elo-empty">No completed contest placements available yet.</div>';
        return;
      }

      const tbody = rows.map(row => `
        <tr>
          <td>${row.rank}</td>
          <td>${row.name}</td>
          <td class="rating-col">${row.ratingDisplay}</td>
          <td>${row.contests}</td>
          <td class="record-col">${row.wins}-${row.losses}-${row.draws}</td>
        </tr>
      `).join('');

      eloContainer.innerHTML = `
        <table class="rating-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th class="rating-col">Rating</th>
              <th>Contests</th>
              <th class="record-col">W-L-D</th>
            </tr>
          </thead>
          <tbody>${tbody}</tbody>
        </table>
      `;
    }

    function buildEloStandings(contestIds, teamGroups, mode = 'normal') {
      if (!contestIds.length || !teamGroups.length) {
        return [];
      }

      const eloMode = mode || 'normal';
      const ratingState = new Map();

      const ensureTeam = (group) => {
        if (!group) return null;
        let record = ratingState.get(group.id);
        if (!record) {
          record = {
            id: group.id,
            name: group.displayName,
            rating: ELO_BASE_RATING,
            wins: 0,
            losses: 0,
            draws: 0,
            contests: 0
          };
          ratingState.set(group.id, record);
        }
        return record;
      };

      teamGroups.forEach(group => ensureTeam(group));

      for (const contestId of contestIds) {
        const contestData = contestCache.get(contestId);
        if (!contestData?.ranklist) continue;

        const condensed = new Map();
        for (const group of teamGroups) {
          const match = findBestGroupMatch(group, contestData.ranklist, contestData.participants);
          const rankValue = Number(match?.entry?.rank);
          if (!Number.isFinite(rankValue)) continue;
          const existing = condensed.get(group.id);
          if (!existing || rankValue < existing.rank) {
            condensed.set(group.id, { group, rank: rankValue });
          }
        }

        if (!condensed.size && eloMode !== 'zero-participation') {
          continue;
        }

        let ordered = Array.from(condensed.values()).sort((a, b) => a.rank - b.rank);

        if (!ordered.length && eloMode === 'zero-participation') {
          ordered = teamGroups.map(group => ({ group, rank: Number.MAX_SAFE_INTEGER }));
        }

        if (eloMode === 'zero-participation') {
          const present = new Set(ordered.map(item => item.group.id));
          teamGroups.forEach(group => {
            if (!present.has(group.id)) {
              ordered.push({ group, rank: Number.MAX_SAFE_INTEGER });
              present.add(group.id);
            }
          });
          ordered = ordered.sort((a, b) => a.rank - b.rank);
        }

        const seenThisContest = new Set();

        ordered.forEach(entry => {
          const record = ensureTeam(entry.group);
          if (record && !seenThisContest.has(record.id)) {
            record.contests += 1;
            seenThisContest.add(record.id);
          }
        });

        for (let i = 0; i < ordered.length; i++) {
          for (let j = i + 1; j < ordered.length; j++) {
            const teamA = ensureTeam(ordered[i].group);
            const teamB = ensureTeam(ordered[j].group);
            if (!teamA || !teamB) continue;
            const expectedA = 1 / (1 + Math.pow(10, (teamB.rating - teamA.rating) / 400));
            const expectedB = 1 - expectedA;
            let scoreA = 1;
            let scoreB = 0;

            if (ordered[i].rank === ordered[j].rank) {
              scoreA = 0.5;
              scoreB = 0.5;
              teamA.draws += 1;
              teamB.draws += 1;
            } else {
              teamA.wins += 1;
              teamB.losses += 1;
            }

            let deltaA = ELO_K_FACTOR * (scoreA - expectedA);
            let deltaB = ELO_K_FACTOR * (scoreB - expectedB);

            if (eloMode === 'gain-only') {
              if (deltaA < 0) deltaA = 0;
              if (deltaB < 0) deltaB = 0;
            }

            teamA.rating += deltaA;
            teamB.rating += deltaB;
          }
        }
      }

      return Array.from(ratingState.values())
        .map(record => ({
          ...record,
          ratingDisplay: formatRating(record.rating)
        }))
        .sort((a, b) => {
          if (b.rating !== a.rating) return b.rating - a.rating;
          return a.name.localeCompare(b.name);
        })
        .map((record, index) => ({
          ...record,
          rank: index + 1
        }));
    }

    async function renderResults({ forceRefetch = false, useCacheOnly = false, showSpinner = false, silentErrors = false } = {}) {
      const container = document.getElementById('results');
      const { contestIds, teamGroups } = collectInputs();

      prepareAggregateView(contestIds);
      refreshAggregateRanking();
      refreshEloStandings();

      if (!contestIds.length) {
        if (!silentErrors) {
          container.innerHTML = '<div class="error">Please enter at least one contest ID.</div>';
        }
        return false;
      }

      if (!teamGroups.length) {
        // Don't clear contests, just return
        return false;
      }

      if (useCacheOnly) {
        const missingCache = contestIds.some(id => !contestCache.has(id));
        if (missingCache) {
          return false;
        }
      }

      if (showSpinner) {
        container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Loading contest data...</p></div>';
      }

      const fragment = document.createDocumentFragment();
      let rendered = false;

      for (const contestId of contestIds) {
        let contestDiv = document.getElementById(`contest-${contestId}`);
        
        if (!contestDiv) {
          contestDiv = document.createElement('div');
          contestDiv.className = 'contest';
          contestDiv.id = `contest-${contestId}`;
          fragment.appendChild(contestDiv);
        } else {
          // Clear existing content to re-render with teams
          contestDiv.innerHTML = '';
        }
        
        // Get contest name from cache or use ID
        const contestName = contestInfoCache.get(contestId) || `Contest ${contestId}`;
        const contestUrl = `https://vjudge.net/contest/${contestId}`;
        contestDiv.innerHTML = `<h2><a href="${contestUrl}" target="_blank" rel="noopener noreferrer">${contestName}</a></h2>`;

        let contestData;
        if (useCacheOnly) {
          contestData = contestCache.get(contestId);
        } else {
          contestData = await ensureContestData(contestId, { forceRefetch });
        }

        if (!contestData || contestData.error) {
          const errorMsg = contestData?.error || 'Unknown error';
          contestDiv.innerHTML += `<div class="error">
            ${errorMsg}
          </div>`;
        } else {
          rendered = true;
          renderTeamsForContest(contestDiv, contestData, teamGroups);
        }

        if (fragment.contains(contestDiv)) {
          // contestDiv is new, keep it in fragment
        } else {
          // contestDiv already in DOM, already updated
        }
      }

      if (fragment.childNodes.length > 0) {
        container.appendChild(fragment);
      }
      refreshAggregateRanking();
      refreshEloStandings();
      return rendered;
    }

    function getParticipantAliases(info = []) {
      const username = info?.[0] || '';
      const displayName = info?.[1] || '';
      const extras = [username, displayName, username.replace(/_/g, ' '), displayName.replace(/_/g, ' ')];
      return extras.filter(Boolean);
    }

    function findTeamRecord(teamName, ranklist, participants = {}) {
      const target = normalizeName(teamName);
      if (!target) return null;

      const rankMatch = ranklist?.find(entry => {
        const aliases = [entry.team_name, entry.teamName, ...(entry.aliases || [])].filter(Boolean);
        return aliases.some(alias => normalizeName(alias) === target);
      });

      if (rankMatch) {
        return { entry: rankMatch };
      }

      for (const [teamId, info] of Object.entries(participants)) {
        const aliases = getParticipantAliases(info);
        if (aliases.some(alias => normalizeName(alias) === target)) {
          return { participant: { id: Number(teamId), info } };
        }
      }

      return null;
    }

    function findBestGroupMatch(teamGroup, ranklist, participants = {}) {
      if (!teamGroup) return null;
      let bestEntry = null;
      let bestAlias = null;
      let fallbackParticipant = null;
      let fallbackAlias = null;

      for (const alias of teamGroup.aliases) {
        const lookup = findTeamRecord(alias, ranklist, participants);
        if (lookup?.entry) {
          const entry = lookup.entry;
          const entryRank = Number(entry.rank);
          const currentBestRank = bestEntry ? Number(bestEntry.rank) : Infinity;
          if (!bestEntry || (Number.isFinite(entryRank) && entryRank < currentBestRank)) {
            bestEntry = entry;
            bestAlias = alias;
          }
        } else if (lookup?.participant && !fallbackParticipant) {
          fallbackParticipant = lookup.participant;
          fallbackAlias = alias;
        }
      }

      return {
        entry: bestEntry,
        participant: fallbackParticipant,
        alias: bestAlias || fallbackAlias || null
      };
    }

    // Initialize on page load
    registerInputListener('contestInput');
    registerInputListener('teamInput');
    initAggregateControls();
    initEloModeControls();
    
    // Listen to upsolve checkbox changes
    const upsolveCheckbox = document.getElementById('includeUpsolve');
    if (upsolveCheckbox) {
      upsolveCheckbox.addEventListener('change', () => {
        // Clear cache to force re-calculation
        contestCache.clear();
        scheduleAutoRefresh();
      });
    }

    console.log('VJudge Contest Checker loaded successfully!');
    console.log('Ready to fetch contest data directly from VJudge API');
  </script>
</body>
</html>
